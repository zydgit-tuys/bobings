import { supabase } from '@/integrations/supabase/client';

export interface CustomerPayment {
    id: string;
    payment_no: string;
    payment_date: string;
    customer_id: string | null;
    amount: number;
    payment_method: 'cash' | 'bank' | 'giro';
    bank_account_id: string | null;
    reference_no: string | null;
    notes: string | null;
    created_at: string;
    updated_at: string;
    created_by: string | null;
}

export interface CreatePaymentData {
    payment_date: string;
    customer_id: string;
    amount: number;
    payment_method: 'cash' | 'bank' | 'giro';
    bank_account_id?: string | null;
    reference_no?: string | null;
    notes?: string | null;
    allocations: {
        sales_order_id: string;
        allocated_amount: number;
    }[];
}

export interface PaymentFilters {
    startDate?: string;
    endDate?: string;
    customerId?: string;
    paymentMethod?: string;
}

export interface OutstandingOrder {
    id: string;
    order_no: string;
    order_date: string;
    total_amount: number;
    paid_amount: number;
    outstanding_amount: number;
}

export const getCustomerPayments = async (filters?: PaymentFilters) => {
    let query = supabase
        .from('customer_payments')
        .select('*')
        .order('payment_date', { ascending: false })
        .order('created_at', { ascending: false });

    if (filters?.startDate) {
        query = query.gte('payment_date', filters.startDate);
    }

    if (filters?.endDate) {
        query = query.lte('payment_date', filters.endDate);
    }

    if (filters?.customerId) {
        query = query.eq('customer_id', filters.customerId);
    }

    if (filters?.paymentMethod) {
        query = query.eq('payment_method', filters.paymentMethod);
    }

    const { data, error } = await query;

    if (error) throw error;
    return data as CustomerPayment[];
};

export const getCustomerPayment = async (id: string) => {
    const { data, error } = await supabase
        .from('customer_payments')
        .select(`
      *,
      customer_payment_allocations (
        id,
        sales_order_id,
        allocated_amount
      )
    `)
        .eq('id', id)
        .single();

    if (error) throw error;
    return data;
};

export const createCustomerPayment = async (data: CreatePaymentData) => {
    // 1. Create payment record (payment_no will be auto-generated by trigger)
    const { data: payment, error: paymentError } = await supabase
        .from('customer_payments')
        .insert({
            payment_date: data.payment_date,
            customer_id: data.customer_id,
            amount: data.amount,
            payment_method: data.payment_method,
            bank_account_id: data.bank_account_id,
            reference_no: data.reference_no,
            notes: data.notes,
        })
        .select()
        .single();

    if (paymentError) throw paymentError;

    // 2. Create allocations
    if (data.allocations && data.allocations.length > 0) {
        const allocations = data.allocations.map(alloc => ({
            payment_id: payment.id,
            sales_order_id: alloc.sales_order_id,
            allocated_amount: alloc.allocated_amount,
        }));

        const { error: allocError } = await supabase
            .from('customer_payment_allocations')
            .insert(allocations);

        if (allocError) throw allocError;
    }

    // 3. Call auto-journal Edge Function
    try {
        await supabase.functions.invoke('auto-journal-customer-payment', {
            body: { payment_id: payment.id },
        });
    } catch (journalError) {
        console.error('Auto-journal error:', journalError);
        // Don't throw - payment already created
    }

    return payment;
};

// Simplified version - get from sales_orders directly
export const getCustomerOutstandingOrders = async (customerId: string) => {
    const { data: orders, error } = await supabase
        .from('v_sales_order_payments')
        .select('id, desty_order_no, order_date, total_amount, paid_amount, outstanding_amount')
        .eq('customer_id', customerId)
        .eq('status', 'completed')
        .gt('outstanding_amount', 0)
        .order('order_date', { ascending: false });

    if (error) {
        console.error('Error fetching outstanding orders:', error);
        return [];
    }

    return (orders || []).map(order => ({
        id: order.id,
        order_no: order.desty_order_no,
        order_date: order.order_date,
        total_amount: order.total_amount || 0,
        paid_amount: order.paid_amount || 0,
        outstanding_amount: order.outstanding_amount || 0,
    })) as OutstandingOrder[];
};
